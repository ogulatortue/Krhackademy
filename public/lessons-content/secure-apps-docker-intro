<section class="content-block">
    <h2><i class="fas fa-question-circle" aria-hidden="true"></i> Qu'est-ce que Docker ?</h2>
    <p>
        Docker est un logiciel Open Source qui a révolutionné la manière de développer, déployer et exécuter des applications. Il utilise une technologie de <strong>conteneurisation</strong> pour empaqueter une application avec toutes ses dépendances (bibliothèques, outils, code) dans un "conteneur" isolé.
    </p>
    <p>
        L'avantage principal est la portabilité : un conteneur créé sur la machine d'un développeur fonctionnera à l'identique sur n'importe quel autre serveur équipé de Docker, éliminant ainsi le fameux problème : "Ça marche sur ma machine !".
    </p>
</section>

<section class="content-block">
    <h2><i class="fas fa-cubes" aria-hidden="true"></i> Virtualisation vs. Conteneurisation</h2>
    <p>
        Pour comprendre Docker, il faut le distinguer de la virtualisation traditionnelle.
    </p>
    <ul>
        <li><strong>Virtualisation :</strong> Un hyperviseur (comme VirtualBox ou VMware) permet de créer des machines virtuelles (VM) complètes. Chaque VM embarque son propre système d'exploitation invité (Guest OS), ce qui consomme beaucoup de ressources (disque, RAM, CPU).</li>
        <li><strong>Conteneurisation :</strong> Le moteur Docker s'exécute directement sur le système d'exploitation de l'hôte (Host OS). Les conteneurs partagent le même noyau que l'hôte. Ils n'embarquent que l'application et ses dépendances, ce qui les rend extrêmement légers, rapides à démarrer et moins gourmands en ressources.</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-book" aria-hidden="true"></i> Le Vocabulaire de Docker</h2>
    <p>L'écosystème Docker repose sur trois concepts fondamentaux :</p>
    <ul>
        <li><strong>Dockerfile :</strong> C'est un simple fichier texte qui agit comme un plan de construction. Il contient une série d'instructions (quelle image de base utiliser, quels fichiers copier, quelles commandes lancer) que Docker suit pour créer une image.</li>
        <li><strong>Image :</strong> C'est le résultat de la construction d'un Dockerfile. Une image est un modèle statique et non modifiable qui contient tout le nécessaire pour exécuter une application. On peut la voir comme un "instantané" ou un "template".</li>
        <li><strong>Conteneur :</strong> C'est une instance en cours d'exécution d'une image. C'est un environnement isolé et vivant dans lequel l'application s'exécute. On peut démarrer, arrêter, et supprimer des conteneurs à partir d'une seule et même image.</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-sitemap" aria-hidden="true"></i> Architecture et Commandes</h2>
    <p>
        Docker fonctionne sur un modèle client-serveur. Le <strong>client Docker</strong> (la commande `docker` que vous tapez) communique avec le <strong>démon Docker</strong> (un service qui tourne en arrière-plan sur l'hôte). Ce démon gère la construction, l'exécution et la distribution des conteneurs. Les images peuvent être stockées localement ou tirées d'un <strong>Registry</strong>, un entrepôt d'images comme Docker Hub.
    </p>
    <h3>Commandes de base :</h3>
    <ul>
        <li><code>docker pull [image]</code> : Télécharge une image depuis un registry.</li>
        <li><code>docker run [image]</code> : Crée et lance un conteneur à partir d'une image.</li>
        <li><code>docker ps</code> : Liste les conteneurs en cours d'exécution.</li>
        <li><code>docker images</code> : Liste les images stockées localement.</li>
        <li><code>docker logs [conteneur]</code> : Affiche les logs d'un conteneur.</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-shield-alt" aria-hidden="true"></i> Docker et la Cybersécurité</h2>
    <p>
        Les conteneurs offrent une isolation grâce à des fonctionnalités du noyau Linux comme les <strong>Namespaces</strong> (qui isolent les processus, les réseaux, etc.) et les <strong>Cgroups</strong> (qui limitent l'utilisation des ressources comme le CPU et la RAM). Cependant, cette isolation n'est pas parfaite.
    </p>
    <h3>Bonnes pratiques de sécurité :</h3>
    <ul>
        <li><strong>Ne pas utiliser l'utilisateur root :</strong> Évitez d'exécuter des processus en tant que root à l'intérieur des conteneurs.</li>
        <li><strong>Utiliser des images légères :</strong> Préférez des images de base minimalistes (comme Alpine) pour réduire la surface d'attaque.</li>
        <li><strong>Ne pas utiliser le flag `--privileged` :</strong> Ce flag désactive la plupart des mécanismes de sécurité et donne au conteneur un accès quasi total à l'hôte.</li>
        <li><strong>Ne pas monter la socket Docker :</strong> Partager le fichier `/var/run/docker.sock` dans un conteneur équivaut à donner les clés de l'hôte, car il permet de contrôler le démon Docker.</li>
        <li><strong>Mettre le système de fichiers en lecture seule :</strong> Exécutez les conteneurs avec l'option `--read-only` pour empêcher les modifications malveillantes.</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-cogs" aria-hidden="true"></i> Aller plus loin : Orchestration et Alternatives</h2>
    <p>
        Pour gérer des applications complexes composées de plusieurs conteneurs, on utilise des outils d'orchestration.
    </p>
    <ul>
        <li><strong>Docker Compose :</strong> Idéal pour le développement, il permet de définir et de lancer une application multi-conteneurs à partir d'un unique fichier de configuration `docker-compose.yml`.</li>
        <li><strong>Kubernetes & Docker Swarm :</strong> Ce sont des orchestrateurs conçus pour la production. Ils gèrent des clusters de machines, automatisent le déploiement, la mise à l'échelle et la gestion des conteneurs à grande échelle.</li>
        <li><strong>Podman :</strong> C'est une alternative populaire à Docker. Sa principale différence est son architecture "daemonless" (sans démon central), ce qui lui permet de fonctionner nativement en mode "rootless" (sans droits administrateur), un avantage majeur pour la sécurité.</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-laptop-code" aria-hidden="true"></i> Exercices Pratiques</h2>

    <h3>Exercice 1 : Lancer un conteneur et explorer le réseau</h3>
    <p>
        <strong>Objectif :</strong> Se familiariser avec la commande `docker run` et comprendre comment un conteneur interagit avec son hôte sur le réseau.
    </p>
    <details>
        <summary style="cursor: pointer;">Afficher / Masquer la Solution</summary><br>
        <div class="solution-content">
            <ol>
                <li><strong>Installer Docker sur votre machine (Debian/Ubuntu) :</strong></li>
            </ol>
            <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code>sudo apt update
sudo apt install docker.io docker-compose -y
sudo systemctl start docker
sudo systemctl enable docker</code></pre><br>
            <ol start="2">
                <li><strong>Lancer un conteneur Alpine en mode interactif :</strong></li>
            </ol>
            <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code>docker run -it alpine sh</code></pre>
            <p>Vous êtes maintenant dans un terminal à l'intérieur du conteneur.</p><br>
            <ol start="3">
                <li><strong>Pinger une adresse externe pour vérifier la connectivité :</strong></li>
            </ol>
            <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code># A l'intérieur du conteneur
ping -c 4 google.com</code></pre>
            <p>Cela montre que par défaut, le conteneur a accès à Internet via le réseau de l'hôte.</p>
        </div>
    </details>

    <hr style="margin: 30px 0;">

    <h3>Exercice 2 : Déployer un serveur web Nginx</h3>
    <p>
        <strong>Objectif :</strong> Lancer un service en arrière-plan et exposer un port du conteneur sur le réseau de l'hôte pour y accéder depuis un navigateur.
    </p>
    <details>
        <summary style="cursor: pointer;">Afficher / Masquer la Solution</summary><br>
        <div class="solution-content">
            <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code>docker run --name mon-serveur-web -p 8080:80 -d nginx</code></pre><br>
            <p><strong>Explication des options :</strong></p>
            <ul>
                <li><code>--name mon-serveur-web</code> : Donne un nom facile à retenir à notre conteneur.</li>
                <li><code>-p 8080:80</code> : Publie le port 80 du conteneur (port par défaut de Nginx) sur le port 8080 de votre machine hôte.</li>
                <li><code>-d</code> : Lance le conteneur en mode "détaché" (en arrière-plan).</li>
                <li><code>nginx</code> : Le nom de l'image à utiliser.</li>
            </ul>
            <p>Ouvrez maintenant votre navigateur et allez à l'adresse `http://localhost:8080`. Vous devriez voir la page d'accueil de Nginx !</p>
        </div>
    </details>

    <hr style="margin: 30px 0;">

    <h3>Exercice 3 : Construire sa propre image</h3>
    <p>
        <strong>Objectif :</strong> Créer une image Docker personnalisée à l'aide d'un `Dockerfile` pour une simple application web Python.
    </p>
    <details>
        <summary style="cursor: pointer;">Afficher / Masquer la Solution</summary><br>
        <div class="solution-content">
            <ol>
                <li><strong>Créez un dossier pour votre projet et placez-y deux fichiers :</strong></li><br>
                <p>Fichier 1 : <code>app.py</code></p>
                <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code>from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "Bonjour le monde depuis mon conteneur Docker !"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)</code></pre><br>
                <p>Fichier 2 : <code>Dockerfile</code></p>
                <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code># Utiliser une image Python officielle comme base
FROM python:3.8-slim

# Définir le répertoire de travail dans le conteneur
WORKDIR /app

# Copier le code de l'application dans le conteneur
COPY app.py .

# Installer les dépendances
RUN pip install Flask

# Commande à exécuter au démarrage du conteneur
CMD ["python", "app.py"]</code></pre>
            </ol><br>
            <ol start="2">
                <li><strong>Construire l'image :</strong> Dans votre terminal, à la racine de votre projet :</li>
            </ol>
            <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code>docker build -t mon-app-python .</code></pre><br>
            <ol start="3">
                <li><strong>Lancer un conteneur à partir de votre nouvelle image :</strong></li>
            </ol>
            <pre style="background-color:#000; border-radius:5px; padding:10px; font-family:monospace;"><code>docker run -p 5000:5000 mon-app-python</code></pre>
            <p>Visitez `http://localhost:5000` dans votre navigateur pour voir votre application fonctionner !</p>
        </div>
    </details>
</section>

<section class="content-block">
    <h2><i class="fas fa-info-circle" aria-hidden="true"></i>Informations sur le document original</h2>
    <p>
        <b>Titre :</b> Workshop Docker<br>
        <b>Auteur :</b> Alexandre Legendre<br>
        <b>Date de publication :</b> 25 mai 2023
    </p>
</section>


